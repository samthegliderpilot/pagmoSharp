/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGCSHARP
#define SWIGCSHARP
#endif

#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/* Support for throwing C# exceptions from C/C++. There are two types: 
 * Exceptions that take a message and ArgumentExceptions that take a message and a parameter name. */
typedef enum {
  SWIG_CSharpApplicationException,
  SWIG_CSharpArithmeticException,
  SWIG_CSharpDivideByZeroException,
  SWIG_CSharpIndexOutOfRangeException,
  SWIG_CSharpInvalidCastException,
  SWIG_CSharpInvalidOperationException,
  SWIG_CSharpIOException,
  SWIG_CSharpNullReferenceException,
  SWIG_CSharpOutOfMemoryException,
  SWIG_CSharpOverflowException,
  SWIG_CSharpSystemException
} SWIG_CSharpExceptionCodes;

typedef enum {
  SWIG_CSharpArgumentException,
  SWIG_CSharpArgumentNullException,
  SWIG_CSharpArgumentOutOfRangeException
} SWIG_CSharpExceptionArgumentCodes;

typedef void (SWIGSTDCALL* SWIG_CSharpExceptionCallback_t)(const char *);
typedef void (SWIGSTDCALL* SWIG_CSharpExceptionArgumentCallback_t)(const char *, const char *);

typedef struct {
  SWIG_CSharpExceptionCodes code;
  SWIG_CSharpExceptionCallback_t callback;
} SWIG_CSharpException_t;

typedef struct {
  SWIG_CSharpExceptionArgumentCodes code;
  SWIG_CSharpExceptionArgumentCallback_t callback;
} SWIG_CSharpExceptionArgument_t;

static SWIG_CSharpException_t SWIG_csharp_exceptions[] = {
  { SWIG_CSharpApplicationException, NULL },
  { SWIG_CSharpArithmeticException, NULL },
  { SWIG_CSharpDivideByZeroException, NULL },
  { SWIG_CSharpIndexOutOfRangeException, NULL },
  { SWIG_CSharpInvalidCastException, NULL },
  { SWIG_CSharpInvalidOperationException, NULL },
  { SWIG_CSharpIOException, NULL },
  { SWIG_CSharpNullReferenceException, NULL },
  { SWIG_CSharpOutOfMemoryException, NULL },
  { SWIG_CSharpOverflowException, NULL },
  { SWIG_CSharpSystemException, NULL }
};

static SWIG_CSharpExceptionArgument_t SWIG_csharp_exceptions_argument[] = {
  { SWIG_CSharpArgumentException, NULL },
  { SWIG_CSharpArgumentNullException, NULL },
  { SWIG_CSharpArgumentOutOfRangeException, NULL }
};

static void SWIGUNUSED SWIG_CSharpSetPendingException(SWIG_CSharpExceptionCodes code, const char *msg) {
  SWIG_CSharpExceptionCallback_t callback = SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions)/sizeof(SWIG_CSharpException_t)) {
    callback = SWIG_csharp_exceptions[code].callback;
  }
  callback(msg);
}

static void SWIGUNUSED SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpExceptionArgumentCodes code, const char *msg, const char *param_name) {
  SWIG_CSharpExceptionArgumentCallback_t callback = SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions_argument)/sizeof(SWIG_CSharpExceptionArgument_t)) {
    callback = SWIG_csharp_exceptions_argument[code].callback;
  }
  callback(msg, param_name);
}


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionCallbacks_pagmo(
                                                SWIG_CSharpExceptionCallback_t applicationCallback,
                                                SWIG_CSharpExceptionCallback_t arithmeticCallback,
                                                SWIG_CSharpExceptionCallback_t divideByZeroCallback, 
                                                SWIG_CSharpExceptionCallback_t indexOutOfRangeCallback, 
                                                SWIG_CSharpExceptionCallback_t invalidCastCallback,
                                                SWIG_CSharpExceptionCallback_t invalidOperationCallback,
                                                SWIG_CSharpExceptionCallback_t ioCallback,
                                                SWIG_CSharpExceptionCallback_t nullReferenceCallback,
                                                SWIG_CSharpExceptionCallback_t outOfMemoryCallback, 
                                                SWIG_CSharpExceptionCallback_t overflowCallback, 
                                                SWIG_CSharpExceptionCallback_t systemCallback) {
  SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback = applicationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpArithmeticException].callback = arithmeticCallback;
  SWIG_csharp_exceptions[SWIG_CSharpDivideByZeroException].callback = divideByZeroCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIndexOutOfRangeException].callback = indexOutOfRangeCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidCastException].callback = invalidCastCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidOperationException].callback = invalidOperationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIOException].callback = ioCallback;
  SWIG_csharp_exceptions[SWIG_CSharpNullReferenceException].callback = nullReferenceCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOutOfMemoryException].callback = outOfMemoryCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOverflowException].callback = overflowCallback;
  SWIG_csharp_exceptions[SWIG_CSharpSystemException].callback = systemCallback;
}

#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionArgumentCallbacks_pagmo(
                                                SWIG_CSharpExceptionArgumentCallback_t argumentCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentNullCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentOutOfRangeCallback) {
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback = argumentCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentNullException].callback = argumentNullCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentOutOfRangeException].callback = argumentOutOfRangeCallback;
}


/* Callback for returning strings to C# without leaking memory */
typedef char * (SWIGSTDCALL* SWIG_CSharpStringHelperCallback)(const char *);
static SWIG_CSharpStringHelperCallback SWIG_csharp_string_callback = NULL;


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterStringCallback_pagmo(SWIG_CSharpStringHelperCallback callback) {
  SWIG_csharp_string_callback = callback;
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, msg, ""); return nullreturn; } else

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that C# proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#if defined(DEBUG_DIRECTOR_OWNED)
#include <iostream>
#endif
#include <string>
#include <exception>

namespace Swig {
  /* Director base class - not currently used in C# directors */
  class Director {
  };

  /* Base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;

  public:
    DirectorException(const char *msg) : swig_msg(msg) {
    }

    DirectorException(const std::string &msg) : swig_msg(msg) {
    }

    virtual ~DirectorException() throw() {
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }
  };

  /* Pure virtual method exception */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg) : DirectorException(std::string("Attempt to invoke pure virtual method ") + msg) {
    }

    static void raise(const char *msg) {
      throw DirectorPureVirtualException(msg);
    }
  };
}


 #include "pagmo/types.hpp"
 #include "pagmo/bfe.hpp"
 #include "pagmo/population.hpp"
 #include "pagmo/algorithms/gaco.hpp"
 #include "pagmo/threading.hpp"
 #include "problem.h" // this is a manually created item.  We want to include it in the wrappers so the generated cxx code can use the handwritten code for the problem


#include <string>


#include <typeinfo>
#include <stdexcept>


#include <vector>
#include <algorithm>
#include <stdexcept>


SWIGINTERN void SWIG_CSharpException(int code, const char *msg) {
  if (code == SWIG_ValueError) {
    SWIG_CSharpExceptionArgumentCodes exception_code = SWIG_CSharpArgumentOutOfRangeException;
    SWIG_CSharpSetPendingExceptionArgument(exception_code, msg, 0);
  } else {
    SWIG_CSharpExceptionCodes exception_code = SWIG_CSharpApplicationException;
    switch(code) {
    case SWIG_MemoryError:
      exception_code = SWIG_CSharpOutOfMemoryException;
      break;
    case SWIG_IndexError:
      exception_code = SWIG_CSharpIndexOutOfRangeException;
      break;
    case SWIG_DivisionByZero:
      exception_code = SWIG_CSharpDivideByZeroException;
      break;
    case SWIG_IOError:
      exception_code = SWIG_CSharpIOException;
      break;
    case SWIG_OverflowError:
      exception_code = SWIG_CSharpOverflowException;
      break;
    case SWIG_RuntimeError:
    case SWIG_TypeError:
    case SWIG_SyntaxError:
    case SWIG_SystemError:
    case SWIG_UnknownError:
    default:
      exception_code = SWIG_CSharpApplicationException;
      break;
    }
    SWIG_CSharpSetPendingException(exception_code, msg);
  }
}


#include <typeinfo>
#include <stdexcept>


#include <utility>

SWIGINTERN std::vector< double > *new_std_vector_Sl_double_Sg___SWIG_2(int capacity){
        std::vector< double >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< double >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN double std_vector_Sl_double_Sg__getitemcopy(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< double >::value_type const &std_vector_Sl_double_Sg__getitem(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__setitem(std::vector< double > *self,int index,double const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__AddRange(std::vector< double > *self,std::vector< double > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< double > *std_vector_Sl_double_Sg__GetRange(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< double >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_double_Sg__Insert(std::vector< double > *self,int index,double const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__InsertRange(std::vector< double > *self,int index,std::vector< double > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__RemoveAt(std::vector< double > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_double_Sg__RemoveRange(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< double > *std_vector_Sl_double_Sg__Repeat(double const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< double >(count, value);
      }
SWIGINTERN void std_vector_Sl_double_Sg__Reverse__SWIG_0(std::vector< double > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_double_Sg__Reverse__SWIG_1(std::vector< double > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_double_Sg__SetRange(std::vector< double > *self,int index,std::vector< double > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_double_Sg__Contains(std::vector< double > *self,double const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_double_Sg__IndexOf(std::vector< double > *self,double const &value){
        int index = -1;
        std::vector< double >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_double_Sg__LastIndexOf(std::vector< double > *self,double const &value){
        int index = -1;
        std::vector< double >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_double_Sg__Remove(std::vector< double > *self,double const &value){
        std::vector< double >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
          return true;
        }
        return false;
      }
SWIGINTERN std::vector< unsigned long long > *new_std_vector_Sl_unsigned_SS_long_SS_long_Sg___SWIG_2(int capacity){
        std::vector< unsigned long long >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< unsigned long long >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN unsigned long long std_vector_Sl_unsigned_SS_long_SS_long_Sg__getitemcopy(std::vector< unsigned long long > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< unsigned long long >::value_type const &std_vector_Sl_unsigned_SS_long_SS_long_Sg__getitem(std::vector< unsigned long long > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__setitem(std::vector< unsigned long long > *self,int index,unsigned long long const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__AddRange(std::vector< unsigned long long > *self,std::vector< unsigned long long > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< unsigned long long > *std_vector_Sl_unsigned_SS_long_SS_long_Sg__GetRange(std::vector< unsigned long long > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< unsigned long long >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__Insert(std::vector< unsigned long long > *self,int index,unsigned long long const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__InsertRange(std::vector< unsigned long long > *self,int index,std::vector< unsigned long long > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__RemoveAt(std::vector< unsigned long long > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__RemoveRange(std::vector< unsigned long long > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< unsigned long long > *std_vector_Sl_unsigned_SS_long_SS_long_Sg__Repeat(unsigned long long const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< unsigned long long >(count, value);
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__Reverse__SWIG_0(std::vector< unsigned long long > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__Reverse__SWIG_1(std::vector< unsigned long long > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_unsigned_SS_long_SS_long_Sg__SetRange(std::vector< unsigned long long > *self,int index,std::vector< unsigned long long > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_unsigned_SS_long_SS_long_Sg__Contains(std::vector< unsigned long long > *self,unsigned long long const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_unsigned_SS_long_SS_long_Sg__IndexOf(std::vector< unsigned long long > *self,unsigned long long const &value){
        int index = -1;
        std::vector< unsigned long long >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_unsigned_SS_long_SS_long_Sg__LastIndexOf(std::vector< unsigned long long > *self,unsigned long long const &value){
        int index = -1;
        std::vector< unsigned long long >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_unsigned_SS_long_SS_long_Sg__Remove(std::vector< unsigned long long > *self,unsigned long long const &value){
        std::vector< unsigned long long >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
          return true;
        }
        return false;
      }
SWIGINTERN std::vector< std::vector< double > > *new_std_vector_Sl_std_vector_Sl_double_Sg__Sg___SWIG_2(int capacity){
        std::vector< std::vector< double > >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::vector< double > >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::vector< double > std_vector_Sl_std_vector_Sl_double_Sg__Sg__getitemcopy(std::vector< std::vector< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::vector< std::vector< double > >::value_type const &std_vector_Sl_std_vector_Sl_double_Sg__Sg__getitem(std::vector< std::vector< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__setitem(std::vector< std::vector< double > > *self,int index,std::vector< double > const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__AddRange(std::vector< std::vector< double > > *self,std::vector< std::vector< double > > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::vector< double > > *std_vector_Sl_std_vector_Sl_double_Sg__Sg__GetRange(std::vector< std::vector< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::vector< double > >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__Insert(std::vector< std::vector< double > > *self,int index,std::vector< double > const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__InsertRange(std::vector< std::vector< double > > *self,int index,std::vector< std::vector< double > > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__RemoveAt(std::vector< std::vector< double > > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__RemoveRange(std::vector< std::vector< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::vector< double > > *std_vector_Sl_std_vector_Sl_double_Sg__Sg__Repeat(std::vector< double > const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::vector< double > >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__Reverse__SWIG_0(std::vector< std::vector< double > > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__Reverse__SWIG_1(std::vector< std::vector< double > > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_vector_Sl_double_Sg__Sg__SetRange(std::vector< std::vector< double > > *self,int index,std::vector< std::vector< double > > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }


/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "pagmoSharpSwigInterface_wrap.h"

SwigDirector_problemBase::SwigDirector_problemBase() : pagmoWrap::problemBase(), Swig::Director() {
  swig_init_callbacks();
}

SwigDirector_problemBase::~SwigDirector_problemBase() {
  
}


pagmoWrap::vector_double SwigDirector_problemBase::fitness(pagmoWrap::vector_double const &arg0) const {
  pagmoWrap::vector_double c_result ;
  void * jresult = 0 ;
  void * jarg0 = 0 ;
  
  if (!swig_callbackfitness) {
    return pagmoWrap::problemBase::fitness(arg0);
  } else {
    jarg0 = (pagmoWrap::vector_double *) &arg0; 
    jresult = (void *) swig_callbackfitness(jarg0);
    if (!jresult) {
      SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Unexpected null return for type pagmoWrap::vector_double", 0);
      return c_result;
    }
    c_result = *(pagmoWrap::vector_double *)jresult; 
  }
  return c_result;
}

std::pair< pagmoWrap::vector_double, pagmoWrap::vector_double > SwigDirector_problemBase::get_bounds() const {
  std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double > c_result ;
  void * jresult = 0 ;
  
  if (!swig_callbackget_bounds) {
    return pagmoWrap::problemBase::get_bounds();
  } else {
    jresult = (void *) swig_callbackget_bounds();
    if (!jresult) {
      SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Unexpected null return for type std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double >", 0);
      return c_result;
    }
    c_result = *(std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double > *)jresult; 
  }
  return c_result;
}

bool SwigDirector_problemBase::has_batch_fitness() const {
  bool c_result = SwigValueInit< bool >() ;
  unsigned int jresult = 0 ;
  
  if (!swig_callbackhas_batch_fitness) {
    return pagmoWrap::problemBase::has_batch_fitness();
  } else {
    jresult = (unsigned int) swig_callbackhas_batch_fitness();
    c_result = jresult ? true : false; 
  }
  return c_result;
}

std::string SwigDirector_problemBase::get_name() const {
  std::string c_result ;
  char * jresult = 0 ;
  
  if (!swig_callbackget_name) {
    return pagmoWrap::problemBase::get_name();
  } else {
    jresult = (char *) swig_callbackget_name();
    if (!jresult) {
      SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null string", 0);
      return c_result;
    }
    c_result.assign(jresult); 
  }
  return c_result;
}

void SwigDirector_problemBase::swig_connect_director(SWIG_Callback0_t callbackfitness, SWIG_Callback1_t callbackget_bounds, SWIG_Callback2_t callbackhas_batch_fitness, SWIG_Callback3_t callbackget_name) {
  swig_callbackfitness = callbackfitness;
  swig_callbackget_bounds = callbackget_bounds;
  swig_callbackhas_batch_fitness = callbackhas_batch_fitness;
  swig_callbackget_name = callbackget_name;
}

void SwigDirector_problemBase::swig_init_callbacks() {
  swig_callbackfitness = 0;
  swig_callbackget_bounds = 0;
  swig_callbackhas_batch_fitness = 0;
  swig_callbackget_name = 0;
}


#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_problemBase(void * jarg1) {
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_problemBase_fitness(void * jarg1, void * jarg2) {
  void * jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  pagmoWrap::vector_double *arg2 = 0 ;
  pagmoWrap::vector_double result;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  arg2 = (pagmoWrap::vector_double *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmoWrap::vector_double const & type is null", 0);
    return 0;
  } 
  result = ((pagmoWrap::problemBase const *)arg1)->fitness((pagmoWrap::vector_double const &)*arg2);
  jresult = new pagmoWrap::vector_double((const pagmoWrap::vector_double &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_problemBase_fitnessSwigExplicitproblemBase(void * jarg1, void * jarg2) {
  void * jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  pagmoWrap::vector_double *arg2 = 0 ;
  pagmoWrap::vector_double result;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  arg2 = (pagmoWrap::vector_double *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmoWrap::vector_double const & type is null", 0);
    return 0;
  } 
  result = ((pagmoWrap::problemBase const *)arg1)->pagmoWrap::problemBase::fitness((pagmoWrap::vector_double const &)*arg2);
  jresult = new pagmoWrap::vector_double((const pagmoWrap::vector_double &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_problemBase_get_bounds(void * jarg1) {
  void * jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double > result;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  result = ((pagmoWrap::problemBase const *)arg1)->get_bounds();
  jresult = new std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double >((const std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_problemBase_get_boundsSwigExplicitproblemBase(void * jarg1) {
  void * jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double > result;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  result = ((pagmoWrap::problemBase const *)arg1)->pagmoWrap::problemBase::get_bounds();
  jresult = new std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double >((const std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double > &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_problemBase_has_batch_fitness(void * jarg1) {
  unsigned int jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  bool result;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  result = (bool)((pagmoWrap::problemBase const *)arg1)->has_batch_fitness();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_problemBase_has_batch_fitnessSwigExplicitproblemBase(void * jarg1) {
  unsigned int jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  bool result;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  result = (bool)((pagmoWrap::problemBase const *)arg1)->pagmoWrap::problemBase::has_batch_fitness();
  jresult = result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_pagmo_problemBase_get_name(void * jarg1) {
  char * jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  std::string result;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  result = ((pagmoWrap::problemBase const *)arg1)->get_name();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_pagmo_problemBase_get_nameSwigExplicitproblemBase(void * jarg1) {
  char * jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  std::string result;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  result = ((pagmoWrap::problemBase const *)arg1)->pagmoWrap::problemBase::get_name();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_problemBase() {
  void * jresult ;
  pagmoWrap::problemBase *result = 0 ;
  
  result = (pagmoWrap::problemBase *)new SwigDirector_problemBase();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_problemBase_director_connect(void *objarg, SwigDirector_problemBase::SWIG_Callback0_t callback0, SwigDirector_problemBase::SWIG_Callback1_t callback1, SwigDirector_problemBase::SWIG_Callback2_t callback2, SwigDirector_problemBase::SWIG_Callback3_t callback3) {
  pagmoWrap::problemBase *obj = (pagmoWrap::problemBase *)objarg;
  SwigDirector_problemBase *director = static_cast<SwigDirector_problemBase *>(obj);
  director->swig_connect_director(callback0, callback1, callback2, callback3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_problem__SWIG_0() {
  void * jresult ;
  pagmoWrap::problem *result = 0 ;
  
  result = (pagmoWrap::problem *)new pagmoWrap::problem();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_problem__SWIG_1(void * jarg1) {
  void * jresult ;
  pagmoWrap::problemBase *arg1 = (pagmoWrap::problemBase *) 0 ;
  pagmoWrap::problem *result = 0 ;
  
  arg1 = (pagmoWrap::problemBase *)jarg1; 
  result = (pagmoWrap::problem *)new pagmoWrap::problem(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_problem__SWIG_2(void * jarg1) {
  void * jresult ;
  pagmoWrap::problem *arg1 = 0 ;
  pagmoWrap::problem *result = 0 ;
  
  arg1 = (pagmoWrap::problem *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmoWrap::problem const & type is null", 0);
    return 0;
  } 
  result = (pagmoWrap::problem *)new pagmoWrap::problem((pagmoWrap::problem const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_problem(void * jarg1) {
  pagmoWrap::problem *arg1 = (pagmoWrap::problem *) 0 ;
  
  arg1 = (pagmoWrap::problem *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_problem_setBaseProblem(void * jarg1, void * jarg2) {
  pagmoWrap::problem *arg1 = (pagmoWrap::problem *) 0 ;
  pagmoWrap::problemBase *arg2 = (pagmoWrap::problemBase *) 0 ;
  
  arg1 = (pagmoWrap::problem *)jarg1; 
  arg2 = (pagmoWrap::problemBase *)jarg2; 
  (arg1)->setBaseProblem(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_problem_getBaseProblem(void * jarg1) {
  void * jresult ;
  pagmoWrap::problem *arg1 = (pagmoWrap::problem *) 0 ;
  pagmoWrap::problemBase *result = 0 ;
  
  arg1 = (pagmoWrap::problem *)jarg1; 
  result = (pagmoWrap::problemBase *)(arg1)->getBaseProblem();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_problem_fitness(void * jarg1, void * jarg2) {
  void * jresult ;
  pagmoWrap::problem *arg1 = (pagmoWrap::problem *) 0 ;
  pagmoWrap::vector_double *arg2 = 0 ;
  pagmoWrap::vector_double result;
  
  arg1 = (pagmoWrap::problem *)jarg1; 
  arg2 = (pagmoWrap::vector_double *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmoWrap::vector_double const & type is null", 0);
    return 0;
  } 
  result = ((pagmoWrap::problem const *)arg1)->fitness((pagmoWrap::vector_double const &)*arg2);
  jresult = new pagmoWrap::vector_double((const pagmoWrap::vector_double &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_problem_get_bounds(void * jarg1) {
  void * jresult ;
  pagmoWrap::problem *arg1 = (pagmoWrap::problem *) 0 ;
  std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double > result;
  
  arg1 = (pagmoWrap::problem *)jarg1; 
  result = ((pagmoWrap::problem const *)arg1)->get_bounds();
  jresult = new std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double >((const std::pair< pagmoWrap::vector_double,pagmoWrap::vector_double > &)result); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_problem_has_batch_fitness(void * jarg1) {
  unsigned int jresult ;
  pagmoWrap::problem *arg1 = (pagmoWrap::problem *) 0 ;
  bool result;
  
  arg1 = (pagmoWrap::problem *)jarg1; 
  result = (bool)((pagmoWrap::problem const *)arg1)->has_batch_fitness();
  jresult = result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_pagmo_problem_get_name(void * jarg1) {
  char * jresult ;
  pagmoWrap::problem *arg1 = (pagmoWrap::problem *) 0 ;
  std::string result;
  
  arg1 = (pagmoWrap::problem *)jarg1; 
  result = ((pagmoWrap::problem const *)arg1)->get_name();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_Clear(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_Add(void * jarg1, double jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((double const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_DoubleVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type result;
  
  arg1 = (std::vector< double > *)jarg1; 
  result = ((std::vector< double > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_DoubleVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type result;
  
  arg1 = (std::vector< double > *)jarg1; 
  result = ((std::vector< double > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (std::vector< double >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_DoubleVector__SWIG_0() {
  void * jresult ;
  std::vector< double > *result = 0 ;
  
  result = (std::vector< double > *)new std::vector< double >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_DoubleVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< double > *arg1 = 0 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< double > *)new std::vector< double >((std::vector< double > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_DoubleVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< double > *)new_std_vector_Sl_double_Sg___SWIG_2(arg1);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_pagmo_DoubleVector_getitemcopy(void * jarg1, int jarg2) {
  double jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double result;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (double)std_vector_Sl_double_Sg__getitemcopy(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT double SWIGSTDCALL CSharp_pagmo_DoubleVector_getitem(void * jarg1, int jarg2) {
  double jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  std::vector< double >::value_type *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< double >::value_type *) &std_vector_Sl_double_Sg__getitem(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_setitem(void * jarg1, int jarg2, double jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (double)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_double_Sg__setitem(arg1,arg2,(double const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (std::vector< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_double_Sg__AddRange(arg1,(std::vector< double > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_DoubleVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< double > *)std_vector_Sl_double_Sg__GetRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_Insert(void * jarg1, int jarg2, double jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (double)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_double_Sg__Insert(arg1,arg2,(double const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_double_Sg__InsertRange(arg1,arg2,(std::vector< double > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_double_Sg__RemoveAt(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_double_Sg__RemoveRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_DoubleVector_Repeat(double jarg1, int jarg2) {
  void * jresult ;
  double *arg1 = 0 ;
  int arg2 ;
  double temp1 ;
  std::vector< double > *result = 0 ;
  
  temp1 = (double)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< double > *)std_vector_Sl_double_Sg__Repeat((double const &)*arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  std_vector_Sl_double_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_double_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_DoubleVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_double_Sg__SetRange(arg1,arg2,(std::vector< double > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_DoubleVector_Contains(void * jarg1, double jarg2) {
  unsigned int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  bool result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_double_Sg__Contains(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_pagmo_DoubleVector_IndexOf(void * jarg1, double jarg2) {
  int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  int result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_double_Sg__IndexOf(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_pagmo_DoubleVector_LastIndexOf(void * jarg1, double jarg2) {
  int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  int result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_double_Sg__LastIndexOf(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_DoubleVector_Remove(void * jarg1, double jarg2) {
  unsigned int jresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  bool result;
  
  arg1 = (std::vector< double > *)jarg1; 
  temp2 = (double)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_double_Sg__Remove(arg1,(double const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_DoubleVector(void * jarg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_Clear(void * jarg1) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_Add(void * jarg1, unsigned long long jarg2) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  unsigned long long *arg2 = 0 ;
  unsigned long long temp2 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  temp2 = (unsigned long long)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((unsigned long long const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_ULongLongVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  std::vector< unsigned long long >::size_type result;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  result = ((std::vector< unsigned long long > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_ULongLongVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  std::vector< unsigned long long >::size_type result;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  result = ((std::vector< unsigned long long > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  std::vector< unsigned long long >::size_type arg2 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (std::vector< unsigned long long >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_ULongLongVector__SWIG_0() {
  void * jresult ;
  std::vector< unsigned long long > *result = 0 ;
  
  result = (std::vector< unsigned long long > *)new std::vector< unsigned long long >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_ULongLongVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< unsigned long long > *arg1 = 0 ;
  std::vector< unsigned long long > *result = 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned long long > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< unsigned long long > *)new std::vector< unsigned long long >((std::vector< unsigned long long > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_ULongLongVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< unsigned long long > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< unsigned long long > *)new_std_vector_Sl_unsigned_SS_long_SS_long_Sg___SWIG_2(arg1);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned long long SWIGSTDCALL CSharp_pagmo_ULongLongVector_getitemcopy(void * jarg1, int jarg2) {
  unsigned long long jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  unsigned long long result;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (unsigned long long)std_vector_Sl_unsigned_SS_long_SS_long_Sg__getitemcopy(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned long long SWIGSTDCALL CSharp_pagmo_ULongLongVector_getitem(void * jarg1, int jarg2) {
  unsigned long long jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  std::vector< unsigned long long >::value_type *result = 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< unsigned long long >::value_type *) &std_vector_Sl_unsigned_SS_long_SS_long_Sg__getitem(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_setitem(void * jarg1, int jarg2, unsigned long long jarg3) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  unsigned long long *arg3 = 0 ;
  unsigned long long temp3 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (unsigned long long)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_unsigned_SS_long_SS_long_Sg__setitem(arg1,arg2,(unsigned long long const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  std::vector< unsigned long long > *arg2 = 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (std::vector< unsigned long long > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned long long > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_unsigned_SS_long_SS_long_Sg__AddRange(arg1,(std::vector< unsigned long long > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_ULongLongVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< unsigned long long > *result = 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< unsigned long long > *)std_vector_Sl_unsigned_SS_long_SS_long_Sg__GetRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_Insert(void * jarg1, int jarg2, unsigned long long jarg3) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  unsigned long long *arg3 = 0 ;
  unsigned long long temp3 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (unsigned long long)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_unsigned_SS_long_SS_long_Sg__Insert(arg1,arg2,(unsigned long long const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  std::vector< unsigned long long > *arg3 = 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< unsigned long long > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned long long > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_unsigned_SS_long_SS_long_Sg__InsertRange(arg1,arg2,(std::vector< unsigned long long > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_unsigned_SS_long_SS_long_Sg__RemoveAt(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_unsigned_SS_long_SS_long_Sg__RemoveRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_ULongLongVector_Repeat(unsigned long long jarg1, int jarg2) {
  void * jresult ;
  unsigned long long *arg1 = 0 ;
  int arg2 ;
  unsigned long long temp1 ;
  std::vector< unsigned long long > *result = 0 ;
  
  temp1 = (unsigned long long)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< unsigned long long > *)std_vector_Sl_unsigned_SS_long_SS_long_Sg__Repeat((unsigned long long const &)*arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  std_vector_Sl_unsigned_SS_long_SS_long_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_unsigned_SS_long_SS_long_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_ULongLongVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  int arg2 ;
  std::vector< unsigned long long > *arg3 = 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< unsigned long long > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< unsigned long long > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_unsigned_SS_long_SS_long_Sg__SetRange(arg1,arg2,(std::vector< unsigned long long > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_ULongLongVector_Contains(void * jarg1, unsigned long long jarg2) {
  unsigned int jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  unsigned long long *arg2 = 0 ;
  unsigned long long temp2 ;
  bool result;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  temp2 = (unsigned long long)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_unsigned_SS_long_SS_long_Sg__Contains(arg1,(unsigned long long const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_pagmo_ULongLongVector_IndexOf(void * jarg1, unsigned long long jarg2) {
  int jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  unsigned long long *arg2 = 0 ;
  unsigned long long temp2 ;
  int result;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  temp2 = (unsigned long long)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_unsigned_SS_long_SS_long_Sg__IndexOf(arg1,(unsigned long long const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_pagmo_ULongLongVector_LastIndexOf(void * jarg1, unsigned long long jarg2) {
  int jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  unsigned long long *arg2 = 0 ;
  unsigned long long temp2 ;
  int result;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  temp2 = (unsigned long long)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_unsigned_SS_long_SS_long_Sg__LastIndexOf(arg1,(unsigned long long const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_ULongLongVector_Remove(void * jarg1, unsigned long long jarg2) {
  unsigned int jresult ;
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  unsigned long long *arg2 = 0 ;
  unsigned long long temp2 ;
  bool result;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  temp2 = (unsigned long long)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_unsigned_SS_long_SS_long_Sg__Remove(arg1,(unsigned long long const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_ULongLongVector(void * jarg1) {
  std::vector< unsigned long long > *arg1 = (std::vector< unsigned long long > *) 0 ;
  
  arg1 = (std::vector< unsigned long long > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_Clear(void * jarg1) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_Add(void * jarg1, void * jarg2) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (std::vector< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((std::vector< double > const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< std::vector< double > >::size_type result;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  result = ((std::vector< std::vector< double > > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< std::vector< double > >::size_type result;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  result = ((std::vector< std::vector< double > > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< std::vector< double > >::size_type arg2 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (std::vector< std::vector< double > >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_VectorDoubleVector__SWIG_0() {
  void * jresult ;
  std::vector< std::vector< double > > *result = 0 ;
  
  result = (std::vector< std::vector< double > > *)new std::vector< std::vector< double > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_VectorDoubleVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::vector< double > > *arg1 = 0 ;
  std::vector< std::vector< double > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::vector< double > > *)new std::vector< std::vector< double > >((std::vector< std::vector< double > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_VectorDoubleVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::vector< double > > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::vector< double > > *)new_std_vector_Sl_std_vector_Sl_double_Sg__Sg___SWIG_2(arg1);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< double > result;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_vector_Sl_double_Sg__Sg__getitemcopy(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = new std::vector< double >((const std::vector< double > &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< double > >::value_type *result = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< double > >::value_type *) &std_vector_Sl_std_vector_Sl_double_Sg__Sg__getitem(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__setitem(arg1,arg2,(std::vector< double > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  std::vector< std::vector< double > > *arg2 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (std::vector< std::vector< double > > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_vector_Sl_double_Sg__Sg__AddRange(arg1,(std::vector< std::vector< double > > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::vector< double > > *result = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::vector< double > > *)std_vector_Sl_std_vector_Sl_double_Sg__Sg__GetRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< double > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< double > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__Insert(arg1,arg2,(std::vector< double > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__InsertRange(arg1,arg2,(std::vector< std::vector< double > > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__RemoveAt(arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__RemoveRange(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< double > *arg1 = 0 ;
  int arg2 ;
  std::vector< std::vector< double > > *result = 0 ;
  
  arg1 = (std::vector< double > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::vector< double > > *)std_vector_Sl_std_vector_Sl_double_Sg__Sg__Repeat((std::vector< double > const &)*arg1,arg2);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  std_vector_Sl_std_vector_Sl_double_Sg__Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  } catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_VectorDoubleVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  int arg2 ;
  std::vector< std::vector< double > > *arg3 = 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::vector< double > > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::vector< double > > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_vector_Sl_double_Sg__Sg__SetRange(arg1,arg2,(std::vector< std::vector< double > > const &)*arg3);
  } catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_VectorDoubleVector(void * jarg1) {
  std::vector< std::vector< double > > *arg1 = (std::vector< std::vector< double > > *) 0 ;
  
  arg1 = (std::vector< std::vector< double > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_PairOfDoubleVectors__SWIG_0() {
  void * jresult ;
  std::pair< std::vector< double >,std::vector< double > > *result = 0 ;
  
  result = (std::pair< std::vector< double >,std::vector< double > > *)new std::pair< std::vector< double >,std::vector< double > >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_PairOfDoubleVectors__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  std::vector< double > arg1 ;
  std::vector< double > arg2 ;
  std::vector< double > *argp1 ;
  std::vector< double > *argp2 ;
  std::pair< std::vector< double >,std::vector< double > > *result = 0 ;
  
  argp1 = (std::vector< double > *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< double >", 0);
    return 0;
  }
  arg1 = *argp1; 
  argp2 = (std::vector< double > *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null std::vector< double >", 0);
    return 0;
  }
  arg2 = *argp2; 
  result = (std::pair< std::vector< double >,std::vector< double > > *)new std::pair< std::vector< double >,std::vector< double > >(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_PairOfDoubleVectors__SWIG_2(void * jarg1) {
  void * jresult ;
  std::pair< std::vector< double >,std::vector< double > > *arg1 = 0 ;
  std::pair< std::vector< double >,std::vector< double > > *result = 0 ;
  
  arg1 = (std::pair< std::vector< double >,std::vector< double > > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::pair< std::vector< double >,std::vector< double > > const & type is null", 0);
    return 0;
  } 
  result = (std::pair< std::vector< double >,std::vector< double > > *)new std::pair< std::vector< double >,std::vector< double > >((std::pair< std::vector< double >,std::vector< double > > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_PairOfDoubleVectors_first_set(void * jarg1, void * jarg2) {
  std::pair< std::vector< double >,std::vector< double > > *arg1 = (std::pair< std::vector< double >,std::vector< double > > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  
  arg1 = (std::pair< std::vector< double >,std::vector< double > > *)jarg1; 
  arg2 = (std::vector< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  if (arg1) (arg1)->first = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_PairOfDoubleVectors_first_get(void * jarg1) {
  void * jresult ;
  std::pair< std::vector< double >,std::vector< double > > *arg1 = (std::pair< std::vector< double >,std::vector< double > > *) 0 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::pair< std::vector< double >,std::vector< double > > *)jarg1; 
  result = (std::vector< double > *) & ((arg1)->first);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_PairOfDoubleVectors_second_set(void * jarg1, void * jarg2) {
  std::pair< std::vector< double >,std::vector< double > > *arg1 = (std::pair< std::vector< double >,std::vector< double > > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  
  arg1 = (std::pair< std::vector< double >,std::vector< double > > *)jarg1; 
  arg2 = (std::vector< double > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< double > const & type is null", 0);
    return ;
  } 
  if (arg1) (arg1)->second = *arg2;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_PairOfDoubleVectors_second_get(void * jarg1) {
  void * jresult ;
  std::pair< std::vector< double >,std::vector< double > > *arg1 = (std::pair< std::vector< double >,std::vector< double > > *) 0 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::pair< std::vector< double >,std::vector< double > > *)jarg1; 
  result = (std::vector< double > *) & ((arg1)->second);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_PairOfDoubleVectors(void * jarg1) {
  std::pair< std::vector< double >,std::vector< double > > *arg1 = (std::pair< std::vector< double >,std::vector< double > > *) 0 ;
  
  arg1 = (std::pair< std::vector< double >,std::vector< double > > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_bfe__SWIG_2() {
  void * jresult ;
  pagmo::bfe *result = 0 ;
  
  result = (pagmo::bfe *)new pagmo::bfe();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_bfe__SWIG_4(void * jarg1) {
  void * jresult ;
  pagmo::bfe *arg1 = 0 ;
  pagmo::bfe *result = 0 ;
  
  arg1 = (pagmo::bfe *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::bfe const & type is null", 0);
    return 0;
  } 
  result = (pagmo::bfe *)new pagmo::bfe((pagmo::bfe const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_pagmo_bfe_get_name(void * jarg1) {
  char * jresult ;
  pagmo::bfe *arg1 = (pagmo::bfe *) 0 ;
  std::string result;
  
  arg1 = (pagmo::bfe *)jarg1; 
  result = ((pagmo::bfe const *)arg1)->get_name();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_pagmo_bfe_get_extra_info(void * jarg1) {
  char * jresult ;
  pagmo::bfe *arg1 = (pagmo::bfe *) 0 ;
  std::string result;
  
  arg1 = (pagmo::bfe *)jarg1; 
  result = ((pagmo::bfe const *)arg1)->get_extra_info();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_pagmo_bfe_get_thread_safety(void * jarg1) {
  int jresult ;
  pagmo::bfe *arg1 = (pagmo::bfe *) 0 ;
  pagmo::thread_safety result;
  
  arg1 = (pagmo::bfe *)jarg1; 
  result = (pagmo::thread_safety)((pagmo::bfe const *)arg1)->get_thread_safety();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_bfe_is_valid(void * jarg1) {
  unsigned int jresult ;
  pagmo::bfe *arg1 = (pagmo::bfe *) 0 ;
  bool result;
  
  arg1 = (pagmo::bfe *)jarg1; 
  result = (bool)((pagmo::bfe const *)arg1)->is_valid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_bfe_get_ptr(void * jarg1) {
  void * jresult ;
  pagmo::bfe *arg1 = (pagmo::bfe *) 0 ;
  void *result = 0 ;
  
  arg1 = (pagmo::bfe *)jarg1; 
  result = (void *)((pagmo::bfe const *)arg1)->get_ptr();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_bfe(void * jarg1) {
  pagmo::bfe *arg1 = (pagmo::bfe *) 0 ;
  
  arg1 = (pagmo::bfe *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_population__SWIG_3(void * jarg1, unsigned long jarg2, unsigned int jarg3) {
  void * jresult ;
  pagmoWrap::problem arg1 ;
  pagmo::population::size_type arg2 ;
  unsigned int arg3 ;
  pagmoWrap::problem *argp1 ;
  pagmo::population *result = 0 ;
  
  argp1 = (pagmoWrap::problem *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null pagmoWrap::problem", 0);
    return 0;
  }
  arg1 = *argp1; 
  arg2 = (pagmo::population::size_type)jarg2; 
  arg3 = (unsigned int)jarg3; 
  result = (pagmo::population *)new pagmo::population(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_population__SWIG_4(void * jarg1, unsigned long jarg2) {
  void * jresult ;
  pagmoWrap::problem arg1 ;
  pagmo::population::size_type arg2 ;
  pagmoWrap::problem *argp1 ;
  pagmo::population *result = 0 ;
  
  argp1 = (pagmoWrap::problem *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null pagmoWrap::problem", 0);
    return 0;
  }
  arg1 = *argp1; 
  arg2 = (pagmo::population::size_type)jarg2; 
  result = (pagmo::population *)new pagmo::population(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_population__SWIG_5(void * jarg1) {
  void * jresult ;
  pagmoWrap::problem arg1 ;
  pagmoWrap::problem *argp1 ;
  pagmo::population *result = 0 ;
  
  argp1 = (pagmoWrap::problem *)jarg1; 
  if (!argp1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null pagmoWrap::problem", 0);
    return 0;
  }
  arg1 = *argp1; 
  result = (pagmo::population *)new pagmo::population(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_population_push_back__SWIG_0(void * jarg1, void * jarg2) {
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::vector_double *arg2 = 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  arg2 = (pagmo::vector_double *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::vector_double const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((pagmo::vector_double const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_population_push_back__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::vector_double *arg2 = 0 ;
  pagmo::vector_double *arg3 = 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  arg2 = (pagmo::vector_double *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::vector_double const & type is null", 0);
    return ;
  } 
  arg3 = (pagmo::vector_double *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::vector_double const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((pagmo::vector_double const &)*arg2,(pagmo::vector_double const &)*arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_population_random_decision_vector(void * jarg1) {
  void * jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::vector_double result;
  
  arg1 = (pagmo::population *)jarg1; 
  result = ((pagmo::population const *)arg1)->random_decision_vector();
  jresult = new pagmo::vector_double((const pagmo::vector_double &)result); 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_population_best_idx__SWIG_0(void * jarg1) {
  unsigned long jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::population::size_type result;
  
  arg1 = (pagmo::population *)jarg1; 
  result = ((pagmo::population const *)arg1)->best_idx();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_population_best_idx__SWIG_1(void * jarg1, void * jarg2) {
  unsigned long jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::vector_double *arg2 = 0 ;
  pagmo::population::size_type result;
  
  arg1 = (pagmo::population *)jarg1; 
  arg2 = (pagmo::vector_double *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::vector_double const & type is null", 0);
    return 0;
  } 
  result = ((pagmo::population const *)arg1)->best_idx((pagmo::vector_double const &)*arg2);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_population_best_idx__SWIG_2(void * jarg1, double jarg2) {
  unsigned long jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  double arg2 ;
  pagmo::population::size_type result;
  
  arg1 = (pagmo::population *)jarg1; 
  arg2 = (double)jarg2; 
  result = ((pagmo::population const *)arg1)->best_idx(arg2);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_population_worst_idx__SWIG_0(void * jarg1) {
  unsigned long jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::population::size_type result;
  
  arg1 = (pagmo::population *)jarg1; 
  result = ((pagmo::population const *)arg1)->worst_idx();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_population_worst_idx__SWIG_1(void * jarg1, void * jarg2) {
  unsigned long jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::vector_double *arg2 = 0 ;
  pagmo::population::size_type result;
  
  arg1 = (pagmo::population *)jarg1; 
  arg2 = (pagmo::vector_double *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::vector_double const & type is null", 0);
    return 0;
  } 
  result = ((pagmo::population const *)arg1)->worst_idx((pagmo::vector_double const &)*arg2);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_population_worst_idx__SWIG_2(void * jarg1, double jarg2) {
  unsigned long jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  double arg2 ;
  pagmo::population::size_type result;
  
  arg1 = (pagmo::population *)jarg1; 
  arg2 = (double)jarg2; 
  result = ((pagmo::population const *)arg1)->worst_idx(arg2);
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_population_champion_x(void * jarg1) {
  void * jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::vector_double result;
  
  arg1 = (pagmo::population *)jarg1; 
  result = ((pagmo::population const *)arg1)->champion_x();
  jresult = new pagmo::vector_double((const pagmo::vector_double &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_population_champion_f(void * jarg1) {
  void * jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::vector_double result;
  
  arg1 = (pagmo::population *)jarg1; 
  result = ((pagmo::population const *)arg1)->champion_f();
  jresult = new pagmo::vector_double((const pagmo::vector_double &)result); 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_pagmo_population_size(void * jarg1) {
  unsigned long jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::population::size_type result;
  
  arg1 = (pagmo::population *)jarg1; 
  result = ((pagmo::population const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_population_set_xf(void * jarg1, unsigned long jarg2, void * jarg3, void * jarg4) {
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::population::size_type arg2 ;
  pagmo::vector_double *arg3 = 0 ;
  pagmo::vector_double *arg4 = 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  arg2 = (pagmo::population::size_type)jarg2; 
  arg3 = (pagmo::vector_double *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::vector_double const & type is null", 0);
    return ;
  } 
  arg4 = (pagmo::vector_double *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::vector_double const & type is null", 0);
    return ;
  } 
  (arg1)->set_xf(arg2,(pagmo::vector_double const &)*arg3,(pagmo::vector_double const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_population_set_x(void * jarg1, unsigned long jarg2, void * jarg3) {
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmo::population::size_type arg2 ;
  pagmo::vector_double *arg3 = 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  arg2 = (pagmo::population::size_type)jarg2; 
  arg3 = (pagmo::vector_double *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::vector_double const & type is null", 0);
    return ;
  } 
  (arg1)->set_x(arg2,(pagmo::vector_double const &)*arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_population_get_problem(void * jarg1) {
  void * jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  pagmoWrap::problem *result = 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  result = (pagmoWrap::problem *) &((pagmo::population const *)arg1)->get_problem();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_population_get_f(void * jarg1) {
  void * jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  std::vector< pagmo::vector_double > *result = 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  result = (std::vector< pagmo::vector_double > *) &((pagmo::population const *)arg1)->get_f();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_population_get_x(void * jarg1) {
  void * jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  std::vector< pagmo::vector_double > *result = 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  result = (std::vector< pagmo::vector_double > *) &((pagmo::population const *)arg1)->get_x();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_population_get_ID(void * jarg1) {
  void * jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  std::vector< unsigned long long > *result = 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  result = (std::vector< unsigned long long > *) &((pagmo::population const *)arg1)->get_ID();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_population_get_seed(void * jarg1) {
  unsigned int jresult ;
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  unsigned int result;
  
  arg1 = (pagmo::population *)jarg1; 
  result = (unsigned int)((pagmo::population const *)arg1)->get_seed();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_population(void * jarg1) {
  pagmo::population *arg1 = (pagmo::population *) 0 ;
  
  arg1 = (pagmo::population *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_0(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4, double jarg5, unsigned int jarg6, unsigned int jarg7, unsigned int jarg8, unsigned int jarg9, double jarg10, unsigned int jarg11, unsigned int jarg12) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int arg9 ;
  double arg10 ;
  bool arg11 ;
  unsigned int arg12 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (unsigned int)jarg6; 
  arg7 = (unsigned int)jarg7; 
  arg8 = (unsigned int)jarg8; 
  arg9 = (unsigned int)jarg9; 
  arg10 = (double)jarg10; 
  arg11 = jarg11 ? true : false; 
  arg12 = (unsigned int)jarg12; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_1(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4, double jarg5, unsigned int jarg6, unsigned int jarg7, unsigned int jarg8, unsigned int jarg9, double jarg10, unsigned int jarg11) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int arg9 ;
  double arg10 ;
  bool arg11 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (unsigned int)jarg6; 
  arg7 = (unsigned int)jarg7; 
  arg8 = (unsigned int)jarg8; 
  arg9 = (unsigned int)jarg9; 
  arg10 = (double)jarg10; 
  arg11 = jarg11 ? true : false; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_2(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4, double jarg5, unsigned int jarg6, unsigned int jarg7, unsigned int jarg8, unsigned int jarg9, double jarg10) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int arg9 ;
  double arg10 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (unsigned int)jarg6; 
  arg7 = (unsigned int)jarg7; 
  arg8 = (unsigned int)jarg8; 
  arg9 = (unsigned int)jarg9; 
  arg10 = (double)jarg10; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_3(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4, double jarg5, unsigned int jarg6, unsigned int jarg7, unsigned int jarg8, unsigned int jarg9) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int arg9 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (unsigned int)jarg6; 
  arg7 = (unsigned int)jarg7; 
  arg8 = (unsigned int)jarg8; 
  arg9 = (unsigned int)jarg9; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_4(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4, double jarg5, unsigned int jarg6, unsigned int jarg7, unsigned int jarg8) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (unsigned int)jarg6; 
  arg7 = (unsigned int)jarg7; 
  arg8 = (unsigned int)jarg8; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_5(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4, double jarg5, unsigned int jarg6, unsigned int jarg7) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (unsigned int)jarg6; 
  arg7 = (unsigned int)jarg7; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_6(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4, double jarg5, unsigned int jarg6) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  unsigned int arg6 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  arg6 = (unsigned int)jarg6; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_7(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4, double jarg5) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  arg5 = (double)jarg5; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4,arg5);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_8(unsigned int jarg1, unsigned int jarg2, double jarg3, double jarg4) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  arg4 = (double)jarg4; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_9(unsigned int jarg1, unsigned int jarg2, double jarg3) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  double arg3 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (double)jarg3; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_10(unsigned int jarg1, unsigned int jarg2) {
  void * jresult ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_11(unsigned int jarg1) {
  void * jresult ;
  unsigned int arg1 ;
  pagmo::gaco *result = 0 ;
  
  arg1 = (unsigned int)jarg1; 
  result = (pagmo::gaco *)new pagmo::gaco(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_new_gaco__SWIG_12() {
  void * jresult ;
  pagmo::gaco *result = 0 ;
  
  result = (pagmo::gaco *)new pagmo::gaco();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_gaco_evolve(void * jarg1, void * jarg2) {
  void * jresult ;
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  SwigValueWrapper< pagmo::population > arg2 ;
  pagmo::population *argp2 ;
  SwigValueWrapper< pagmo::population > result;
  
  arg1 = (pagmo::gaco *)jarg1; 
  argp2 = (pagmo::population *)jarg2; 
  if (!argp2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "Attempt to dereference null pagmo::population", 0);
    return 0;
  }
  arg2 = *argp2; 
  result = ((pagmo::gaco const *)arg1)->evolve(arg2);
  jresult = new pagmo::population((const pagmo::population &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_gaco_set_seed(void * jarg1, unsigned int jarg2) {
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  unsigned int arg2 ;
  
  arg1 = (pagmo::gaco *)jarg1; 
  arg2 = (unsigned int)jarg2; 
  (arg1)->set_seed(arg2);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_gaco_get_seed(void * jarg1) {
  unsigned int jresult ;
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  unsigned int result;
  
  arg1 = (pagmo::gaco *)jarg1; 
  result = (unsigned int)((pagmo::gaco const *)arg1)->get_seed();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_gaco_get_verbosity(void * jarg1) {
  unsigned int jresult ;
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  unsigned int result;
  
  arg1 = (pagmo::gaco *)jarg1; 
  result = (unsigned int)((pagmo::gaco const *)arg1)->get_verbosity();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_pagmo_gaco_get_gen(void * jarg1) {
  unsigned int jresult ;
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  unsigned int result;
  
  arg1 = (pagmo::gaco *)jarg1; 
  result = (unsigned int)((pagmo::gaco const *)arg1)->get_gen();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_gaco_set_bfe(void * jarg1, void * jarg2) {
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  pagmo::bfe *arg2 = 0 ;
  
  arg1 = (pagmo::gaco *)jarg1; 
  arg2 = (pagmo::bfe *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "pagmo::bfe const & type is null", 0);
    return ;
  } 
  (arg1)->set_bfe((pagmo::bfe const &)*arg2);
}


SWIGEXPORT char * SWIGSTDCALL CSharp_pagmo_gaco_get_name(void * jarg1) {
  char * jresult ;
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  std::string result;
  
  arg1 = (pagmo::gaco *)jarg1; 
  result = ((pagmo::gaco const *)arg1)->get_name();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT char * SWIGSTDCALL CSharp_pagmo_gaco_get_extra_info(void * jarg1) {
  char * jresult ;
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  std::string result;
  
  arg1 = (pagmo::gaco *)jarg1; 
  result = ((pagmo::gaco const *)arg1)->get_extra_info();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_pagmo_gaco_get_log(void * jarg1) {
  void * jresult ;
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  pagmo::gaco::log_type *result = 0 ;
  
  arg1 = (pagmo::gaco *)jarg1; 
  result = (pagmo::gaco::log_type *) &((pagmo::gaco const *)arg1)->get_log();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_pagmo_delete_gaco(void * jarg1) {
  pagmo::gaco *arg1 = (pagmo::gaco *) 0 ;
  
  arg1 = (pagmo::gaco *)jarg1; 
  delete arg1;
}


#ifdef __cplusplus
}
#endif

